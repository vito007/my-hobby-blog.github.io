
[{"content":"Dlho som sa pohrával s myšlienkou vytvoriť si vlastný blog, ale vždy ma odradili vysoké mesačné poplatky za hosting a komplikované nastavenia. Chcel som niečo jednoduché, rýchle a hlavne lacné - ideálne zadarmo alebo za minimálne náklady. Po dlhšom bádaní som objavil kombináciu moderných technológií, ktoré mi umožnili vytvoriť profesionálny blog prakticky zadarmo. Tradičné hostingové služby často stoja 5-15 EUR mesačne, čo je pre hobby blog neúmerne veľa. Rozhodol som sa preto hľadať alternatívy v cloudových službách, ktoré ponúkajú štedré free tier plány. Moja filozofia bola jasná: minimálne náklady, maximálna funkcionalita a spoľahlivosť. Po výskume som sa rozhodol pre kombináciu statického site generátora a cloudového hostingu. Výsledok? Moderný, rýchly blog za cenu len jednej domény ročne.\nPoužité technológie a náklady # Vlastná doména: 6,89 EUR/rok Cloudflare (DNS): 0,00 EUR Azure Static Web Apps: 0,00 EUR Hugo (generátor stránok): 0,00 EUR GitHub (verzovanie a CI/CD): 0,00 EUR Celkové náklady: 6,89 EUR ročne\nKrok za krokom návod # 1. Kúpa domény # Vyberte si registrátora domén (ja som použil [názov registrátora]) Zadajte požadované doménové meno a dokončite nákup Získate prístupové údaje na správu DNS nastavení 2. Nastavenie Cloudflare # Zaregistrujte sa na cloudflare.com Pridajte vašu doménu do Cloudflare Zmeňte nameservery u vášho registrátora na tie, ktoré poskytne Cloudflare Počkajte na aktiváciu (zvyčajne 24 hodín) 3. Vytvorenie GitHub repozitára # Zaregistrujte sa na github.com (ak nemáte účet) Vytvorte nový verejný repozitár pre váš blog Klonujte repozitár na váš počítač pomocou git clone [URL] 4. Inštalácia Hugo # Stiahnite Hugo z gohugo.io Pre Windows: stiahnite ZIP, rozbaľte a pridajte do PATH Pre macOS: brew install hugo Pre Linux: sudo apt install hugo alebo stiahnite .deb balík Overte inštaláciu: hugo version 5. Vytvorenie Hugo stránky # Prejdite do priečinka s repozitárom Vytvorte novú Hugo stránku: hugo new site . Vyberte a nainštalujte tému (napríklad): git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke Upravte hugo.toml a nastavte tému: theme = 'ananke' 6. Konfigurácia Hugo # Otvorte hugo.toml a nastavte základné parametre: baseURL = \u0026#39;https://vasa-domena.sk\u0026#39; languageCode = \u0026#39;sk\u0026#39; title = \u0026#39;Názov vášho blogu\u0026#39; theme = \u0026#39;ananke\u0026#39; Prispôsobte menu, footer a ďalšie nastavenia podľa témy 7. Vytvorenie Azure Static Web App # Zaregistrujte sa na portal.azure.com Vytvorte novú \u0026ldquo;Static Web App\u0026rdquo; Pripojte k vášmu GitHub repozitáru Nastavte build settings: Source: /, App location: /, Output location: /public Azure automaticky vytvorí GitHub Action pre deployment 8. Nastavenie DNS v Cloudflare # V Cloudflare prejdite na DNS nastavenia Vytvorte CNAME záznam: www → [váš-azure-url].azurestaticapps.net Vytvorte A záznam pre root doménu alebo CNAME alias Nastavte SSL/TLS na \u0026ldquo;Full\u0026rdquo; v Cloudflare 9. Písanie obsahu # Vytvorte nový príspevok: hugo new posts/moj-prvy-prispevok.md Editujte súbor v content/posts/ Nastavte draft: false v front matter Použite Markdown syntax pre formátovanie 10. Publikovanie # Otestujte lokálne: hugo server -D Commitnite zmeny: git add ., git commit -m \u0026quot;Nový príspevok\u0026quot; Pushujte na GitHub: git push origin main Azure automaticky spustí deployment a publikuje zmeny Výhody tohto riešenia # Rýchlosť: Statické súbory sa načítajú bleskovo Bezpečnosť: Žiadna databáza = žiadne bezpečnostné problémy Škálovateľnosť: Cloudflare a Azure zvládnu aj vysokú návštevnosť Nízke náklady: Len cena domény Verzovanie: Celá história zmien v Git Automatické SSL: Zadarmo HTTPS certifikáty Tento setup mi perfektne vyhovuje a môžem ho odporučiť každému, kto hľadá lacné a spoľahlivé riešenie pre osobný blog či portfólio.\n","date":"8 September 2025","externalUrl":null,"permalink":"/posts/ako_som_si_vytvoril_blog/","section":"Posts","summary":"Kompletný návod ako si vytvoriť moderný blog za cenu len jednej domény ročne pomocou Hugo, Azure Static Web Apps a Cloudflare.","title":"Ako som si vytvoril lacný blog za 6,89 EUR ročne","type":"posts"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/tags/azure/","section":"Tags","summary":"","title":"Azure","type":"tags"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/tags/blog/","section":"Tags","summary":"","title":"Blog","type":"tags"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/tags/cloudflare/","section":"Tags","summary":"","title":"Cloudflare","type":"tags"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/tags/hugo/","section":"Tags","summary":"","title":"Hugo","type":"tags"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/","section":"My hobby blog","summary":"","title":"My hobby blog","type":"page"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/tags/n%C3%A1vod/","section":"Tags","summary":"","title":"Návod","type":"tags"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/categories/technol%C3%B3gie/","section":"Categories","summary":"","title":"Technológie","type":"categories"},{"content":"","date":"8 September 2025","externalUrl":null,"permalink":"/categories/web-development/","section":"Categories","summary":"","title":"Web Development","type":"categories"},{"content":"","date":"4 September 2025","externalUrl":null,"permalink":"/tags/git/","section":"Tags","summary":"","title":"Git","type":"tags"},{"content":" Git pre začiatočníkov - Kompletný sprievodca # Ahoj! Ako tvoj učiteľ ťa naučím pracovať s Gitom krok za krokom. Git je nástroj na verzovanie kódu - predstav si ho ako \u0026ldquo;cestovanie v čase\u0026rdquo; pre tvoje projekty.\nKrok 1: Čo je Git a prečo ho potrebuješ? # Git ti umožňuje:\nSledovať zmeny v kóde Vrátiť sa k starším verziám Spolupracovať s ostatnými programátormi Uchovávať zálohy svojej práce Predstav si, že píšeš esej. S Gitom môžeš uložiť každú verziu, vidieť čo si zmenil a vrátiť sa k predchádzajúcej verzii, ak niečo pokazíš.\nKrok 2: Inštalácia Gitu # Windows: Stiahni Git z git-scm.com\nMac: brew install git alebo stiahni z git-scm.com\nLinux: sudo apt install git\nOveriť inštaláciu:\ngit --version Krok 3: Prvotné nastavenie # git config --global user.name \u0026#34;Tvoje Meno\u0026#34; git config --global user.email \u0026#34;tvoj@email.com\u0026#34; Krok 4: Základné pojmy (musíš ich vedieť!) # Repository (repo) = priečinok s projektom pod správou Gitu Commit = \u0026ldquo;snímka\u0026rdquo; projektu v určitom čase Branch = vetva vývoja projektu Remote = vzdialené úložisko (napr. GitHub) Krok 5: Vytvorenie prvého repozitára # # Vytvor priečinok pre projekt mkdir moj-projekt cd moj-projekt # Inicializuj Git repozitár git init Teraz máš prázdny Git repozitár!\nKrok 6: Prvý commit (tvoja prvá \u0026ldquo;snímka\u0026rdquo;) # # Vytvor súbor echo \u0026#34;Ahoj svet!\u0026#34; \u0026gt; index.html # Pridaj súbor do \u0026#34;staging area\u0026#34; git add index.html # Urob commit git commit -m \u0026#34;Pridaný prvý súbor\u0026#34; Vysvetlenie:\ngit add = priprav súbor na commit git commit -m \u0026quot;správa\u0026quot; = urob snímku so správou Krok 7: Sledovanie stavu # # Zobraz stav repozitára git status # Zobraz históriu commitov git log # Zobraz zmeny v súboroch git diff Krok 8: Praktický príklad - editácia a nový commit # # Uprav súbor echo \u0026#34;\u0026lt;h1\u0026gt;Moja stránka\u0026lt;/h1\u0026gt;\u0026#34; \u0026gt; index.html # Zobraz zmeny git diff # Pridaj zmeny git add index.html # Urob nový commit git commit -m \u0026#34;Pridaný nadpis\u0026#34; Krok 9: Práca s vetvami (branches) # # Vytvor novú vetvu git branch nova-funkcia # Prepni sa na novú vetvu git checkout nova-funkcia # ALEBO modernejšie: git switch nova-funkcia # Vytvor a prepni sa naraz git checkout -b ina-vetva Prečo vetvy? Umožňujú ti pracovať na novej funkcii bez ovplyvnenia hlavnej vetvy. Krok 10: Zlučovanie vetiev (merge) # # Prepni sa na hlavnú vetvu git switch main # Zlúč vetvu git merge nova-funkcia Krok 11: Pripojenie na GitHub/vzdialené úložisko # najprv na stranke https://github.com/settings/tokens vygenerujem token ktory pouzijem v prikaze\n# Pripoj vzdialené úložisko git remote set-url origin https://TOKEN@github.com/USERNAME/REPO/ # Nahraj kód na GitHub git push -u origin main Krok 12: Sťahovanie zmien # # Stiahni zmeny zo vzdialeného úložiska git pull origin main Krok 13: Praktické cvičenie # Vytvor súbor style.css Pridaj ho do Gitu (git add) Urob commit Vytvor novú vetvu styling Uprav CSS súbor Commitni zmeny Prepni sa na main Zlúč vetvy echo \u0026#34;body { color: blue; }\u0026#34; \u0026gt; style.css git add style.css git commit -m \u0026#34;Pridaný CSS súbor\u0026#34; git checkout -b styling echo \u0026#34;body { color: red; background: yellow; }\u0026#34; \u0026gt; style.css git add style.css git commit -m \u0026#34;Zmenené farby\u0026#34; git checkout main git merge styling Krok 14: Riešenie konfliktov # Keď dva ľudia zmenia ten istý riadok, Git nevie ktorú verziu použiť:\n# Git označí konflikt v súbore takto: \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; HEAD Tvoja verzia ======= Verzia z inej vetvy \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; branch-name Riešenie: Uprav súbor ručne, zmaž značky \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;, =======, \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; a urob commit. Krok 15: Užitočné príkazy na záver # # Zobraz všetky vetvy git branch -a # Zmaž vetvu git branch -d nazov-vetvy # Vráť zmeny v súbore git checkout -- nazov-suboru # Zobraz krásnu históriu git log --oneline --graph # Zruš posledný commit (ale ponechaj zmeny) git reset --soft HEAD~1 Tippy pre každodenné používanie # Commituj často - malé, logické zmeny Píš jasné commit správy - napr. \u0026ldquo;Opravená chyba v prihlásení\u0026rdquo; Používaj vetvy - pre každú novú funkciu Testuj pred commitom - uisti sa, že kód funguje Sťahuj zmeny pravidelne - git pull pred začiatkom práce Záver # Pamätaj si: Git je ako záchranná sieť pre tvoj kód. Čím viac ho používaš, tím väčšiu istotu máš, že o svoju prácu nikdy neprídeš!\nTento tutoriál ti poskytol základy práce s Gitom. Pre pokročilejšie témy odporúčam oficiálnu dokumentáciu na git-scm.com. Návod vytvoreny pomocou AI\n","date":"4 September 2025","externalUrl":null,"permalink":"/posts/git/zaklady/","section":"Posts","summary":"","title":"Git pre začiatočníkov - Kompletný sprievodca","type":"posts"},{"content":"","date":"4 September 2025","externalUrl":null,"permalink":"/tags/programovanie/","section":"Tags","summary":"","title":"Programovanie","type":"tags"},{"content":"","date":"4 September 2025","externalUrl":null,"permalink":"/tags/tutorial/","section":"Tags","summary":"","title":"Tutorial","type":"tags"},{"content":"","date":"4 September 2025","externalUrl":null,"permalink":"/categories/tutori%C3%A1ly/","section":"Categories","summary":"","title":"Tutoriály","type":"categories"},{"content":"","date":"4 September 2025","externalUrl":null,"permalink":"/tags/verzovanie/","section":"Tags","summary":"","title":"Verzovanie","type":"tags"},{"content":"","date":"15 January 2025","externalUrl":null,"permalink":"/categories/cloud/","section":"Categories","summary":"","title":"Cloud","type":"categories"},{"content":"","date":"15 January 2025","externalUrl":null,"permalink":"/tags/devops/","section":"Tags","summary":"","title":"Devops","type":"tags"},{"content":"","date":"15 January 2025","externalUrl":null,"permalink":"/categories/devops/","section":"Categories","summary":"","title":"DevOps","type":"categories"},{"content":"","date":"15 January 2025","externalUrl":null,"permalink":"/tags/docker/","section":"Tags","summary":"","title":"Docker","type":"tags"},{"content":" Prečo Docker? Docker revolutionalizoval spôsob, ako vyvíjame a deployujeme aplikácie. Umožňuje zabaliť aplikáciu so všetkými závislostmi do prenosného kontajnera.\n1. Úvod do Dockeru # Čo je Docker? # Docker je platforma na kontajnerizáciu aplikácií. Umožňuje zabaliť aplikáciu a všetky jej závislosti do prenosného kontajnera, ktorý beží rovnako na každom systéme.\nZákladné pojmy: # Image (obraz) - šablóna na vytvorenie kontajnera Container (kontajner) - bežiaca inštancia obrazu Dockerfile - súbor s inštrukciami na vytvorenie obrazu Registry - úložisko obrazov (napr. Docker Hub) 2. Správa Images (obrazov) # Teoretický úvod # Image je read-only šablóna, z ktorej sa vytvárajú kontajnery. Skladá sa z vrstiev (layers), čo umožňuje efektívne zdieľanie a caching.\nZákladné príkazy: # # Stiahnutie obrazu docker pull ubuntu:20.04 # Zoznam lokálnych obrazov docker images # Vytvorenie obrazu z Dockerfile docker build -t moja-app:1.0 . # Odstránenie obrazu docker rmi ubuntu:20.04 # Zobrazenie histórie obrazu docker history ubuntu:20.04 Praktický príklad - vytvorenie vlastného obrazu: # # Dockerfile FROM ubuntu:20.04 RUN apt-get update \u0026amp;\u0026amp; apt-get install -y python3 python3-pip COPY app.py /app/ WORKDIR /app CMD [\u0026#34;python3\u0026#34;, \u0026#34;app.py\u0026#34;] # Vytvorenie obrazu docker build -t python-app:1.0 . 3. Správa Containers (kontajnerov) # Pozor: Kontajnery sú dočasné. Po ich odstránení sa stratia všetky zmeny, ktoré neboli uložené do volumes.\nTeoretický úvod # Kontajner je bežiaca inštancia obrazu. Je to izolované prostredie s vlastným filesystémom, procesmi a sieťovým rozhraním.\nZákladné príkazy: # # Spustenie kontajnera docker run -d --name web-server nginx # Interaktívne spustenie docker run -it ubuntu:20.04 /bin/bash # Zoznam bežiacich kontajnerov docker ps # Zoznam všetkých kontajnerov docker ps -a # Zastavenie kontajnera docker stop web-server # Spustenie zastaveného kontajnera docker start web-server # Odstránenie kontajnera docker rm web-server # Pripojenie do bežiaceho kontajnera docker exec -it web-server /bin/bash Praktický príklad: # # Spustenie web servera s portom a názvom docker run -d --name moj-nginx -p 8080:80 nginx # Kontrola logov docker logs moj-nginx # Pripojenie do kontajnera docker exec -it moj-nginx /bin/bash 4. Sieťovanie (Networking) # Teoretický úvod # Docker poskytuje rôzne typy sietí pre komunikáciu medzi kontajnermi a so vonkajším svetom:\nTypy sietí: # Bridge - Predvolená sieť pre kontajnery na jednom hoste. Kontajnery môžu komunikovať medzi sebou a s internetom. Host - Kontajner používa priamo sieť hosta. Najrýchlejšia možnosť, ale menej izolovaná. None - Kontajner nemá prístup k sieti. Používa sa pre špecifické prípady. Custom - Vlastné definované siete s pokročilými nastaveniami. Základné príkazy: # # Zoznam sietí docker network ls # Vytvorenie vlastnej siete docker network create moja-siet # Spustenie kontajnera v konkrétnej sieti docker run -d --name app1 --network moja-siet nginx # Pripojenie kontajnera do siete docker network connect moja-siet app1 # Odpojenie kontajnera zo siete docker network disconnect moja-siet app1 # Informácie o sieti docker network inspect moja-siet Praktický príklad - komunikácia medzi kontajnermi: # # Vytvorenie vlastnej siete docker network create app-network # Spustenie databázy docker run -d --name mysql-db \\ --network app-network \\ -e MYSQL_ROOT_PASSWORD=heslo123 \\ mysql:8.0 # Spustenie web aplikácie docker run -d --name web-app \\ --network app-network \\ -p 3000:3000 \\ node:16 # Kontajnery sa môžu komunikovať cez názvy # web-app môže pristupovať k databáze cez \u0026#34;mysql-db:3306\u0026#34; 5. Volumes a Storage # Teoretický úvod # Volumes umožňujú trvalé ukladanie dát mimo kontajnera. Existujú tri typy:\nTyp Popis Použitie Named volumes Spravované Dockerom Produkčné databázy Bind mounts Pripojenie priečinka z hosta Vývoj aplikácií tmpfs mounts Dočasné úložisko v pamäti Citlivé dáta Základné príkazy: # # Zoznam volumes docker volume ls # Vytvorenie volume docker volume create moje-data # Spustenie kontajnera s volume docker run -d --name db -v moje-data:/var/lib/mysql mysql:8.0 # Bind mount - pripojenie priečinka docker run -d --name web -v /host/path:/container/path nginx # Informácie o volume docker volume inspect moje-data # Odstránenie volume docker volume rm moje-data Praktický príklad - trvalé uloženie databázy: # # Vytvorenie volume pre databázu docker volume create mysql-data # Spustenie MySQL s trvalým úložiskom docker run -d --name mysql-server \\ -e MYSQL_ROOT_PASSWORD=heslo123 \\ -v mysql-data:/var/lib/mysql \\ -p 3306:3306 \\ mysql:8.0 # Aj po odstránení kontajnera ostanú dáta zachované docker rm -f mysql-server docker run -d --name mysql-server2 \\ -e MYSQL_ROOT_PASSWORD=heslo123 \\ -v mysql-data:/var/lib/mysql \\ -p 3306:3306 \\ mysql:8.0 6. Environment Variables a Konfigurácia # Teoretický úvod # Environment variables umožňujú konfigurovať aplikácie bez zmeny kódu. Docker podporuje rôzne spôsoby ich zadávania.\nZákladné príkazy: # # Nastavenie environment variable docker run -e MYSQL_ROOT_PASSWORD=heslo123 mysql:8.0 # Načítanie z .env súboru docker run --env-file .env mysql:8.0 # Zobrazenie environment variables v kontajneri docker exec container_name env Praktický príklad s .env súborom: # # .env súbor MYSQL_ROOT_PASSWORD=tajne_heslo MYSQL_DATABASE=moja_databaza MYSQL_USER=user MYSQL_PASSWORD=user_heslo # Spustenie s .env súborom docker run -d --name mysql-configured \\ --env-file .env \\ -v mysql-data:/var/lib/mysql \\ mysql:8.0 7. Docker Compose # Tip: Docker Compose je ideálny pre lokálny vývoj a staging prostredia. Pre produkciu zvážte Kubernetes alebo Docker Swarm.\nTeoretický úvod # Docker Compose umožňuje definovať a spravovať viac-kontajnerové aplikácie pomocou YAML súboru. Ideálne pre lokálny vývoj a testing.\nZákladná syntax docker-compose.yml: # version: \u0026#39;3.8\u0026#39; services: web: build: . ports: - \u0026#34;3000:3000\u0026#34; environment: - NODE_ENV=development volumes: - .:/app depends_on: - database database: image: mysql:8.0 environment: MYSQL_ROOT_PASSWORD: heslo123 MYSQL_DATABASE: myapp volumes: - mysql_data:/var/lib/mysql ports: - \u0026#34;3306:3306\u0026#34; volumes: mysql_data: Základné príkazy: # # Spustenie všetkých služieb docker-compose up -d # Zastavenie všetkých služieb docker-compose down # Zobrazenie stavu služieb docker-compose ps # Zobrazenie logov docker-compose logs # Rebuild a reštart docker-compose up --build # Spustenie príkazu v službe docker-compose exec web /bin/bash Komplexný praktický príklad - Web aplikácia s databázou: # Zobrazenie úplného docker-compose.yml # docker-compose.yml version: \u0026#39;3.8\u0026#39; services: # Web aplikácia frontend: build: ./frontend ports: - \u0026#34;3000:3000\u0026#34; environment: - REACT_APP_API_URL=http://backend:5000 volumes: - ./frontend:/app - /app/node_modules depends_on: - backend restart: unless-stopped # Backend API backend: build: ./backend ports: - \u0026#34;5000:5000\u0026#34; environment: - DATABASE_URL=mysql://user:heslo@database:3306/myapp - NODE_ENV=development - REDIS_URL=redis://cache:6379 volumes: - ./backend:/app - /app/node_modules depends_on: - database - cache restart: unless-stopped # MySQL databáza database: image: mysql:8.0 environment: MYSQL_ROOT_PASSWORD: root_heslo MYSQL_DATABASE: myapp MYSQL_USER: user MYSQL_PASSWORD: heslo volumes: - mysql_data:/var/lib/mysql - ./database/init.sql:/docker-entrypoint-initdb.d/init.sql ports: - \u0026#34;3306:3306\u0026#34; restart: unless-stopped # Redis cache cache: image: redis:alpine command: redis-server --appendonly yes volumes: - redis_data:/data ports: - \u0026#34;6379:6379\u0026#34; restart: unless-stopped # Nginx reverse proxy nginx: image: nginx:alpine ports: - \u0026#34;80:80\u0026#34; - \u0026#34;443:443\u0026#34; volumes: - ./nginx/nginx.conf:/etc/nginx/nginx.conf - ./nginx/ssl:/etc/nginx/ssl depends_on: - frontend - backend restart: unless-stopped volumes: mysql_data: redis_data: networks: default: name: myapp-network Spustenie a správa: # # Spustenie celej aplikácie docker-compose up -d # Sledovanie logov konkrétnej služby docker-compose logs -f backend # Reštart konkrétnej služby docker-compose restart backend # Scaling služby docker-compose up --scale backend=3 # Vyčistenie všetkého docker-compose down -v --rmi all 8. Bezpečnosť a Best Practices # Optimalizácia Dockerfile: # # Dobré praktiky FROM node:16-alpine # Vytvorenie non-root usera RUN addgroup -g 1001 -S nodejs \u0026amp;\u0026amp; \\ adduser -S nextjs -u 1001 # Nastavenie working directory WORKDIR /app # Kopírovanie package.json najprv (lepší caching) COPY package*.json ./ RUN npm ci --only=production \u0026amp;\u0026amp; npm cache clean --force # Kopírovanie zdrojového kódu COPY --chown=nextjs:nodejs . . # Nastavenie usera USER nextjs # Definovanie portu EXPOSE 3000 # Health check HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\ CMD curl -f http://localhost:3000/health || exit 1 CMD [\u0026#34;npm\u0026#34;, \u0026#34;start\u0026#34;] Bezpečnostné tipy: # ⚠️ DÔLEŽITÉ: Nikdy neukladajte citlivé údaje priamo do Dockerfile alebo docker-compose.yml! Používajte Docker secrets alebo external configuration.\nDobré praktiky:\n✅ Používajte specific image tags namiesto latest ✅ Spúšťajte kontajnery ako non-root user ✅ Skenujte images na vulnerabilities ✅ Používajte multi-stage builds ❌ Neinkludujte .git, node_modules v build context 9. Monitoring a Debugging # Užitočné príkazy na údržbu: # # Vyčistenie všetkých nepoužívaných objektov docker system prune -a # Vyčistenie volumes docker volume prune # Zobrazenie využitia miesta docker system df # Sledovanie využitia zdrojov docker stats # Export/Import kontajnera docker export container_name \u0026gt; backup.tar docker import backup.tar new_image:tag Monitoring a debugging: # # Sledovanie logov v reálnom čase docker logs -f --tail 100 container_name # Zobrazenie procesov v kontajneri docker top container_name # Inšpekcia kontajnera (detailné informácie) docker inspect container_name # Kopírovanie súborov do/z kontajnera docker cp file.txt container_name:/path/ docker cp container_name:/path/file.txt ./ # Sledovanie udalostí docker events # Zobrazenie port mappings docker port container_name Docker Compose monitoring: # # Zobrazenie využitia zdrojov všetkých služieb docker-compose top # Sledovanie logov všetkých služieb docker-compose logs -f --tail=100 # Validácia compose súboru docker-compose config # Zobrazenie závislostí medzi službami docker-compose ps --services 10. Pokročilé témy # Multi-stage builds # # Build stage FROM node:16-alpine AS builder WORKDIR /app COPY package*.json ./ RUN npm ci COPY . . RUN npm run build # Production stage FROM node:16-alpine AS production WORKDIR /app COPY package*.json ./ RUN npm ci --only=production COPY --from=builder /app/dist ./dist USER node CMD [\u0026#34;npm\u0026#34;, \u0026#34;start\u0026#34;] Docker secrets (pre produkciu): # # Vytvorenie secret echo \u0026#34;moje_tajne_heslo\u0026#34; | docker secret create mysql_password - # Použitie v docker-compose.yml version: \u0026#39;3.8\u0026#39; services: database: image: mysql:8.0 secrets: - mysql_password environment: MYSQL_ROOT_PASSWORD_FILE: /run/secrets/mysql_password secrets: mysql_password: external: true Záver a ďalšie kroky # 🎉 Gratulujeme! Teraz poznáte základy Dockeru. Docker je mocný nástroj, ktorý zjednodušuje deployment a správu aplikácií.\nKľúčové koncepty na zapamätanie: # Images sú šablóny, containers sú bežiace inštancie Volumes zabezpečujú trvalé uloženie dát Networks umožňujú komunikáciu medzi kontajnermi Docker Compose zjednodušuje správu viac-kontajnerových aplikácií Environment variables umožňujú flexibilnú konfiguráciu Ďalšie kroky: # Pre pokročilých: # Kubernetes orchestrácia Docker Swarm clustering CI/CD integrácia Container security scanning Užitočné zdroje: # Docker oficiálna dokumentácia Docker Hub Docker Best Practices 💡 Tip pre začiatočníkov: Začnite s jednoduchými príkladmi a postupne pridávajte komplexnejšie funkcie. Docker vám ušetrí veľa času pri vývoji a deploymente aplikácií! Návod vytvoreny pomocou AI\n","date":"15 January 2025","externalUrl":null,"permalink":"/posts/docker/docker-zaklady-sprievodca/","section":"Posts","summary":"","title":"Docker - Kompletný sprievodca pre začiatočníkov","type":"posts"},{"content":"","date":"15 January 2025","externalUrl":null,"permalink":"/tags/k8s/","section":"Tags","summary":"","title":"K8s","type":"tags"},{"content":"","date":"15 January 2025","externalUrl":null,"permalink":"/tags/kontajneriz%C3%A1cia/","section":"Tags","summary":"","title":"Kontajnerizácia","type":"tags"},{"content":"","date":"15 January 2025","externalUrl":null,"permalink":"/tags/kontajnery/","section":"Tags","summary":"","title":"Kontajnery","type":"tags"},{"content":"","date":"15 January 2025","externalUrl":null,"permalink":"/tags/kubernetes/","section":"Tags","summary":"","title":"Kubernetes","type":"tags"},{"content":" Prečo Kubernetes? Kubernetes (k8s) je de facto štandard pre orchestráciu kontajnerov. Umožňuje automatické nasadzovanie, škálovanie a správu kontajnerizovaných aplikácií v produkčnom prostredí.\n1. Úvod do Kubernetes # Čo je Kubernetes? # Kubernetes je open-source platforma pre orchestráciu kontajnerov. Automatizuje nasadzovanie, škálovanie a správu kontajnerizovaných aplikácií naprieč klastrom serverov.\nZákladné pojmy: # Cluster - skupina uzlov (nodes) spravovaných Kubernetes Node - fyzický alebo virtuálny server v klastri Pod - najmenšia deployovateľná jednotka (jeden alebo viac kontajnerov) Service - abstrakcia pre prístup k aplikáciám Deployment - deklaratívny spôsob správy aplikácií Kubernetes vs Docker Compose: # Aspekt Docker Compose Kubernetes Škála Jeden host Multi-host cluster Škálovanie Manuálne Automatické Load balancing Základný Pokročilý Self-healing Nie Áno Použitie Development/Testing Production 2. Kubernetes Architecture # Teoretický úvod # Kubernetes má master-slave architektúru s control plane a worker nodes.\nControl Plane komponenty: # API Server - centrálny komunikačný bod etcd - distribuovaná databáza stavu klastra Controller Manager - spravuje kontroléry Scheduler - rozhoduje o umiestnení pods Worker Node komponenty: # kubelet - agent komunikujúci s control plane kube-proxy - sieťový proxy Container Runtime - Docker/containerd/CRI-O Inštalácia a setup: # # Inštalácia kubectl (MacOS) brew install kubectl # Overenie inštalácie kubectl version --client # Inštalácia minikube pre lokálny vývoj brew install minikube # Spustenie lokálneho klastra minikube start # Overenie stavu klastra kubectl cluster-info kubectl get nodes Základné kubectl príkazy: # # Zobrazenie všetkých zdrojov kubectl get all # Detailné informácie o uzloch kubectl describe nodes # Kontexty (prepínanie medzi klastrami) kubectl config get-contexts kubectl config use-context minikube # Pomoc kubectl --help kubectl get --help 3. Pods - Základné jednotky # Teoretický úvod # Pod je najmenšia deployovateľná jednotka v Kubernetes. Obsahuje jeden alebo viac úzko súvisiacich kontajnerov, ktoré zdieľajú sieť a storage.\nZákladné operácie s Pods: # # Vytvorenie pod z image kubectl run nginx-pod --image=nginx # Zobrazenie pods kubectl get pods # Detailné informácie o pod kubectl describe pod nginx-pod # Prístup do pod kubectl exec -it nginx-pod -- /bin/bash # Zobrazenie logov kubectl logs nginx-pod # Odstránenie pod kubectl delete pod nginx-pod Pod Manifest (YAML): # # pod.yaml apiVersion: v1 kind: Pod metadata: name: web-pod labels: app: web version: v1 spec: containers: - name: nginx image: nginx:1.21 ports: - containerPort: 80 resources: requests: memory: \u0026#34;64Mi\u0026#34; cpu: \u0026#34;250m\u0026#34; limits: memory: \u0026#34;128Mi\u0026#34; cpu: \u0026#34;500m\u0026#34; - name: sidecar image: busybox command: [\u0026#39;sh\u0026#39;, \u0026#39;-c\u0026#39;, \u0026#39;while true; do echo \u0026#34;$(date): Sidecar running\u0026#34;; sleep 30; done\u0026#39;] # Aplikovanie manifesta kubectl apply -f pod.yaml # Monitorovanie pod kubectl get pod web-pod -w Praktický príklad - Multi-container Pod: # # multi-container-pod.yaml apiVersion: v1 kind: Pod metadata: name: app-with-logging spec: containers: # Hlavná aplikácia - name: app image: nginx:alpine ports: - containerPort: 80 volumeMounts: - name: shared-logs mountPath: /var/log/nginx # Logging sidecar - name: log-processor image: busybox command: [\u0026#39;sh\u0026#39;, \u0026#39;-c\u0026#39;] args: [\u0026#39;tail -f /var/log/nginx/access.log\u0026#39;] volumeMounts: - name: shared-logs mountPath: /var/log/nginx volumes: - name: shared-logs emptyDir: {} 4. Services - Sieťová abstrakcia # Teoretický úvod # Services poskytujú stabilný endpoint pre prístup k pods. Riešia problém dynamických IP adries a load balancing.\nTypy Services: # ClusterIP - interná komunikácia v klastri NodePort - prístup z vonka cez port na uzle LoadBalancer - externý load balancer (cloud provider) ExternalName - DNS alias pre externé služby Základné príkazy: # # Vytvorenie service pre existujúce pods kubectl expose pod web-pod --type=ClusterIP --port=80 # Zobrazenie services kubectl get services kubectl get svc # Detailné informácie kubectl describe service web-pod # Testovanie konektivity kubectl run test-pod --image=busybox -it --rm -- wget -qO- web-pod Service Manifests: # ClusterIP Service: # # service-clusterip.yaml apiVersion: v1 kind: Service metadata: name: web-service spec: selector: app: web ports: - protocol: TCP port: 80 targetPort: 80 type: ClusterIP NodePort Service: # # service-nodeport.yaml apiVersion: v1 kind: Service metadata: name: web-service-external spec: selector: app: web ports: - protocol: TCP port: 80 targetPort: 80 nodePort: 30080 type: NodePort LoadBalancer Service (pre cloud): # # service-loadbalancer.yaml apiVersion: v1 kind: Service metadata: name: web-service-lb spec: selector: app: web ports: - protocol: TCP port: 80 targetPort: 80 type: LoadBalancer Praktický príklad - Service Discovery: # # Vytvorenie deployment s viacerými pods kubectl create deployment web --image=nginx --replicas=3 # Vytvorenie service kubectl expose deployment web --port=80 --type=ClusterIP # Test load balancingu kubectl run test --image=busybox -it --rm -- sh # V kontajneri: # while true; do wget -qO- web; sleep 1; done 5. Deployments - Deklaratívna správa aplikácií # Tip: Deployments sú preferovaný způsob nasazovania aplikácií v Kubernetes. Poskytujú rolling updates, rollbacks a self-healing.\nTeoretický úvod # Deployment je kontrolér, ktorý spravuje ReplicaSets a tým aj Pods. Umožňuje deklaratívne aktualizácie a automatické škálovanie.\nZákladné operácie: # # Vytvorenie deployment kubectl create deployment nginx-app --image=nginx:1.21 # Škálovanie kubectl scale deployment nginx-app --replicas=5 # Rolling update kubectl set image deployment nginx-app nginx=nginx:1.22 # História zmien kubectl rollout history deployment nginx-app # Rollback na predchádzajúcu verziu kubectl rollout undo deployment nginx-app # Status rolling update kubectl rollout status deployment nginx-app Deployment Manifest: # # deployment.yaml apiVersion: apps/v1 kind: Deployment metadata: name: web-deployment labels: app: web spec: replicas: 3 selector: matchLabels: app: web template: metadata: labels: app: web spec: containers: - name: nginx image: nginx:1.21 ports: - containerPort: 80 resources: requests: memory: \u0026#34;64Mi\u0026#34; cpu: \u0026#34;250m\u0026#34; limits: memory: \u0026#34;128Mi\u0026#34; cpu: \u0026#34;500m\u0026#34; livenessProbe: httpGet: path: / port: 80 initialDelaySeconds: 30 periodSeconds: 10 readinessProbe: httpGet: path: / port: 80 initialDelaySeconds: 5 periodSeconds: 5 Deployment stratégie: # RollingUpdate (default): # spec: strategy: type: RollingUpdate rollingUpdate: maxUnavailable: 25% maxSurge: 25% Recreate: # spec: strategy: type: Recreate Praktický príklad - Blue-Green deployment: # # blue-deployment.yaml apiVersion: apps/v1 kind: Deployment metadata: name: app-blue spec: replicas: 3 selector: matchLabels: app: myapp version: blue template: metadata: labels: app: myapp version: blue spec: containers: - name: app image: myapp:v1.0 ports: - containerPort: 8080 --- # service pre blue-green apiVersion: v1 kind: Service metadata: name: app-service spec: selector: app: myapp version: blue # Prepnutie na green pre switch ports: - port: 80 targetPort: 8080 6. ConfigMaps a Secrets - Konfigurácia # Teoretický úvod # ConfigMaps a Secrets umožňujú oddelenie konfigurácie od kódu aplikácie.\nRozdiely: # ConfigMap - nesitlivé konfiguračné dáta (plain text) Secret - citlivé údaje (base64 encoded, môže byť šifrované) ConfigMaps: # # Vytvorenie ConfigMap z command line kubectl create configmap app-config \\ --from-literal=DATABASE_URL=postgresql://db:5432/myapp \\ --from-literal=DEBUG=true # Vytvorenie z súboru kubectl create configmap nginx-config --from-file=nginx.conf # Zobrazenie ConfigMap kubectl get configmaps kubectl describe configmap app-config ConfigMap Manifest: # # configmap.yaml apiVersion: v1 kind: ConfigMap metadata: name: app-config data: database_url: \u0026#34;postgresql://db:5432/myapp\u0026#34; debug_mode: \u0026#34;true\u0026#34; log_level: \u0026#34;info\u0026#34; # Môže obsahovať aj celé súbory nginx.conf: | server { listen 80; location / { proxy_pass http://backend; } } Secrets: # # Vytvorenie Secret kubectl create secret generic db-credentials \\ --from-literal=username=admin \\ --from-literal=password=supersecret # Vytvorenie TLS secret kubectl create secret tls tls-secret \\ --cert=tls.crt \\ --key=tls.key # Zobrazenie secrets kubectl get secrets Secret Manifest: # # secret.yaml apiVersion: v1 kind: Secret metadata: name: db-credentials type: Opaque data: username: YWRtaW4= # base64 encoded \u0026#39;admin\u0026#39; password: c3VwZXJzZWNyZXQ= # base64 encoded \u0026#39;supersecret\u0026#39; Použitie v Pod: # Environment Variables: # apiVersion: v1 kind: Pod metadata: name: app-pod spec: containers: - name: app image: myapp:latest env: - name: DATABASE_URL valueFrom: configMapKeyRef: name: app-config key: database_url - name: DB_PASSWORD valueFrom: secretKeyRef: name: db-credentials key: password Volume Mounts: # apiVersion: v1 kind: Pod metadata: name: app-pod spec: containers: - name: app image: myapp:latest volumeMounts: - name: config-volume mountPath: /etc/config - name: secret-volume mountPath: /etc/secrets readOnly: true volumes: - name: config-volume configMap: name: app-config - name: secret-volume secret: secretName: db-credentials 7. Persistent Volumes - Trvalé úložisko # Teoretický úvod # Kubernetes poskytuje abstrakciu pre storage cez Persistent Volumes (PV) a Persistent Volume Claims (PVC).\nKomponenty: # Persistent Volume (PV) - fyzické úložisko v klastri Persistent Volume Claim (PVC) - požiadavka na úložisko Storage Class - dynamické provisionovanie Storage Classes: # # storageclass.yaml apiVersion: storage.k8s.io/v1 kind: StorageClass metadata: name: fast-ssd provisioner: kubernetes.io/aws-ebs parameters: type: gp2 fsType: ext4 allowVolumeExpansion: true reclaimPolicy: Delete Persistent Volume: # # persistent-volume.yaml apiVersion: v1 kind: PersistentVolume metadata: name: mysql-pv spec: capacity: storage: 10Gi accessModes: - ReadWriteOnce persistentVolumeReclaimPolicy: Retain storageClassName: fast-ssd hostPath: path: /data/mysql Persistent Volume Claim: # # persistent-volume-claim.yaml apiVersion: v1 kind: PersistentVolumeClaim metadata: name: mysql-pvc spec: accessModes: - ReadWriteOnce resources: requests: storage: 5Gi storageClassName: fast-ssd Použitie v Pod/Deployment: # # mysql-deployment.yaml apiVersion: apps/v1 kind: Deployment metadata: name: mysql spec: replicas: 1 selector: matchLabels: app: mysql template: metadata: labels: app: mysql spec: containers: - name: mysql image: mysql:8.0 env: - name: MYSQL_ROOT_PASSWORD valueFrom: secretKeyRef: name: mysql-secret key: password ports: - containerPort: 3306 volumeMounts: - name: mysql-storage mountPath: /var/lib/mysql volumes: - name: mysql-storage persistentVolumeClaim: claimName: mysql-pvc Praktický príklad - StatefulSet pre databázu: # # mysql-statefulset.yaml apiVersion: apps/v1 kind: StatefulSet metadata: name: mysql spec: serviceName: mysql replicas: 1 selector: matchLabels: app: mysql template: metadata: labels: app: mysql spec: containers: - name: mysql image: mysql:8.0 env: - name: MYSQL_ROOT_PASSWORD value: \u0026#34;rootpassword\u0026#34; ports: - containerPort: 3306 volumeMounts: - name: mysql-storage mountPath: /var/lib/mysql volumeClaimTemplates: - metadata: name: mysql-storage spec: accessModes: [\u0026#34;ReadWriteOnce\u0026#34;] resources: requests: storage: 10Gi 8. Ingress - HTTP Load Balancing # Teoretický úvod # Ingress poskytuje HTTP/HTTPS routing do služieb v klastri. Umožňuje definovať pravidlá pre domain-based a path-based routing.\nIngress Controller: # Najprv musíte mať nainštalovaný Ingress Controller:\n# Nginx Ingress Controller kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.8.1/deploy/static/provider/cloud/deploy.yaml # Overenie inštalácie kubectl get pods -n ingress-nginx # Pre minikube minikube addons enable ingress Základný Ingress: # # basic-ingress.yaml apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: web-ingress annotations: nginx.ingress.kubernetes.io/rewrite-target: / spec: rules: - host: myapp.local http: paths: - path: / pathType: Prefix backend: service: name: web-service port: number: 80 Pokročilý Ingress s TLS: # # advanced-ingress.yaml apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: app-ingress annotations: nginx.ingress.kubernetes.io/ssl-redirect: \u0026#34;true\u0026#34; nginx.ingress.kubernetes.io/rate-limit: \u0026#34;100\u0026#34; spec: tls: - hosts: - api.myapp.com - www.myapp.com secretName: tls-secret rules: - host: www.myapp.com http: paths: - path: / pathType: Prefix backend: service: name: frontend-service port: number: 80 - host: api.myapp.com http: paths: - path: /api/v1 pathType: Prefix backend: service: name: backend-service port: number: 8080 - path: /api/v2 pathType: Prefix backend: service: name: backend-v2-service port: number: 8080 Testovanie Ingress: # # Pridanie do /etc/hosts echo \u0026#34;$(minikube ip) myapp.local\u0026#34; | sudo tee -a /etc/hosts # Test cez curl curl http://myapp.local # Získanie Ingress informácií kubectl get ingress kubectl describe ingress web-ingress 9. Namespaces - Izolacia zdrojov # Teoretický úvod # Namespaces poskytujú virtuálnu izoláciu zdrojov v rámci jedného klastra. Umožňujú organizáciu aplikácií podľa prostredí alebo tímov.\nZákladné operácie: # # Zobrazenie namespaces kubectl get namespaces # Vytvorenie namespace kubectl create namespace development kubectl create namespace staging kubectl create namespace production # Prepnutie do namespace kubectl config set-context --current --namespace=development # Zobrazenie všetkých zdrojov v namespace kubectl get all -n development # Odstránenie namespace kubectl delete namespace development Namespace Manifest: # # namespace.yaml apiVersion: v1 kind: Namespace metadata: name: development labels: environment: dev team: frontend Resource Quotas: # # resource-quota.yaml apiVersion: v1 kind: ResourceQuota metadata: name: dev-quota namespace: development spec: hard: requests.cpu: \u0026#34;4\u0026#34; requests.memory: 8Gi limits.cpu: \u0026#34;8\u0026#34; limits.memory: 16Gi persistentvolumeclaims: \u0026#34;10\u0026#34; pods: \u0026#34;20\u0026#34; Network Policies: # # network-policy.yaml apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: deny-all namespace: development spec: podSelector: {} policyTypes: - Ingress - Egress --- apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: allow-frontend-to-backend namespace: development spec: podSelector: matchLabels: app: backend policyTypes: - Ingress ingress: - from: - podSelector: matchLabels: app: frontend ports: - protocol: TCP port: 8080 10. Horizontal Pod Autoscaler (HPA) # Teoretický úvod # HPA automaticky škáluje počet pods na základe využitia CPU, pamäte alebo custom metrík.\nPožiadavky: # # Inštalácia metrics-server kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml # Overenie kubectl get pods -n kube-system | grep metrics-server Vytvorenie HPA: # # HPA na základe CPU kubectl autoscale deployment web-deployment \\ --cpu-percent=50 \\ --min=2 \\ --max=10 # Zobrazenie HPA kubectl get hpa HPA Manifest: # # hpa.yaml apiVersion: autoscaling/v2 kind: HorizontalPodAutoscaler metadata: name: web-hpa spec: scaleTargetRef: apiVersion: apps/v1 kind: Deployment name: web-deployment minReplicas: 2 maxReplicas: 20 metrics: - type: Resource resource: name: cpu target: type: Utilization averageUtilization: 70 - type: Resource resource: name: memory target: type: Utilization averageUtilization: 80 behavior: scaleDown: stabilizationWindowSeconds: 300 policies: - type: Percent value: 10 periodSeconds: 60 scaleUp: stabilizationWindowSeconds: 0 policies: - type: Percent value: 100 periodSeconds: 15 Testovanie autoscalingu: # # Generovanie load kubectl run load-generator --image=busybox -it --rm -- /bin/sh # V kontajneri: # while true; do wget -q -O- http://web-service; done # Sledovanie HPA kubectl get hpa -w # Sledovanie pods kubectl get pods -w 11. Jobs a CronJobs - Dávkové úlohy # Jobs # Jobs zabezpečujú jednorazové spustenie úloh s garantovaným dokončením.\n# job.yaml apiVersion: batch/v1 kind: Job metadata: name: database-migration spec: completions: 1 parallelism: 1 backoffLimit: 3 template: spec: restartPolicy: Never containers: - name: migration image: migrate/migrate:latest command: [\u0026#34;migrate\u0026#34;] args: [\u0026#34;-path\u0026#34;, \u0026#34;/migrations\u0026#34;, \u0026#34;-database\u0026#34;, \u0026#34;postgres://user:pass@db:5432/dbname?sslmode=disable\u0026#34;, \u0026#34;up\u0026#34;] env: - name: DB_HOST value: \u0026#34;postgresql\u0026#34; CronJobs # CronJobs spúšťajú úlohy podľa cronového rozvrhu.\n# cronjob.yaml apiVersion: batch/v1 kind: CronJob metadata: name: backup-job spec: schedule: \u0026#34;0 2 * * *\u0026#34; # Každý deň o 2:00 jobTemplate: spec: template: spec: restartPolicy: OnFailure containers: - name: backup image: postgres:13 command: - /bin/bash - -c args: - pg_dump -h postgresql -U postgres mydb \u0026gt; /backup/backup-$(date +%Y%m%d).sql env: - name: PGPASSWORD valueFrom: secretKeyRef: name: postgres-secret key: password volumeMounts: - name: backup-storage mountPath: /backup volumes: - name: backup-storage persistentVolumeClaim: claimName: backup-pvc 12. Monitoring a Logging # Kubernetes Dashboard: # # Inštalácia Dashboard kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.7.0/aio/deploy/recommended.yaml # Vytvorenie admin usera kubectl create serviceaccount admin-user -n kubernetes-dashboard kubectl create clusterrolebinding admin-user --clusterrole=cluster-admin --serviceaccount=kubernetes-dashboard:admin-user # Získanie tokenu kubectl -n kubernetes-dashboard create token admin-user # Proxy pre prístup kubectl proxy # http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/ Prometheus a Grafana stack: # # prometheus-namespace.yaml apiVersion: v1 kind: Namespace metadata: name: monitoring --- # prometheus-deployment.yaml apiVersion: apps/v1 kind: Deployment metadata: name: prometheus namespace: monitoring spec: replicas: 1 selector: matchLabels: app: prometheus template: metadata: labels: app: prometheus spec: containers: - name: prometheus image: prom/prometheus:latest ports: - containerPort: 9090 volumeMounts: - name: prometheus-config mountPath: /etc/prometheus/ - name: prometheus-storage mountPath: /prometheus/ volumes: - name: prometheus-config configMap: name: prometheus-config - name: prometheus-storage emptyDir: {} Centralizované logovanie s EFK: # # elasticsearch.yaml apiVersion: apps/v1 kind: StatefulSet metadata: name: elasticsearch namespace: logging spec: serviceName: elasticsearch replicas: 1 selector: matchLabels: app: elasticsearch template: metadata: labels: app: elasticsearch spec: containers: - name: elasticsearch image: elasticsearch:7.17.9 env: - name: discovery.type value: single-node - name: ES_JAVA_OPTS value: \u0026#34;-Xms512m -Xmx512m\u0026#34; ports: - containerPort: 9200 volumeMounts: - name: elasticsearch-data mountPath: /usr/share/elasticsearch/data volumeClaimTemplates: - metadata: name: elasticsearch-data spec: accessModes: [\u0026#34;ReadWriteOnce\u0026#34;] resources: requests: storage: 10Gi 13. Bezpečnosť v Kubernetes # ⚠️ DÔLEŽITÉ: Bezpečnosť v Kubernetes je komplexná téma. Implementujte viacvrstvový security model.\nRBAC (Role-Based Access Control): # # rbac.yaml apiVersion: v1 kind: ServiceAccount metadata: name: app-reader namespace: development --- apiVersion: rbac.authorization.k8s.io/v1 kind: Role metadata: name: pod-reader namespace: development rules: - apiGroups: [\u0026#34;\u0026#34;] resources: [\u0026#34;pods\u0026#34;, \u0026#34;services\u0026#34;] verbs: [\u0026#34;get\u0026#34;, \u0026#34;list\u0026#34;, \u0026#34;watch\u0026#34;] --- apiVersion: rbac.authorization.k8s.io/v1 kind: RoleBinding metadata: name: read-pods namespace: development subjects: - kind: ServiceAccount name: app-reader namespace: development roleRef: kind: Role name: pod-reader apiGroup: rbac.authorization.k8s.io Pod Security Standards: # # pod-security.yaml apiVersion: v1 kind: Pod metadata: name: secure-pod spec: securityContext: runAsNonRoot: true runAsUser: 1000 runAsGroup: 3000 fsGroup: 2000 containers: - name: app image: nginx:alpine securityContext: allowPrivilegeEscalation: false readOnlyRootFilesystem: true runAsNonRoot: true runAsUser: 1000 capabilities: drop: - ALL resources: requests: memory: \u0026#34;64Mi\u0026#34; cpu: \u0026#34;250m\u0026#34; limits: memory: \u0026#34;128Mi\u0026#34; cpu: \u0026#34;500m### Network Security Policies: ```yaml # network-security.yaml apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: default-deny-ingress namespace: production spec: podSelector: {} policyTypes: - Ingress --- apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: allow-nginx-ingress namespace: production spec: podSelector: matchLabels: app: web policyTypes: - Ingress ingress: - from: - namespaceSelector: matchLabels: name: ingress-nginx ports: - protocol: TCP port: 80 Secrets Management - Sealed Secrets: # # Inštalácia Sealed Secrets kubectl apply -f https://github.com/bitnami-labs/sealed-secrets/releases/download/v0.18.0/controller.yaml # Inštalácia kubeseal CLI brew install kubeseal # Vytvorenie sealed secret echo -n mypassword | kubectl create secret generic mysecret --dry-run=client --from-file=password=/dev/stdin -o yaml | kubeseal -o yaml \u0026gt; mysealedsecret.yaml # Aplikovanie sealed secret kubectl apply -f mysealedsecret.yaml 14. Helm - Package Manager pre Kubernetes # Teoretický úvod # Helm je package manager pre Kubernetes, ktorý umožňuje definovať, inštalovať a upgradovať komplexné Kubernetes aplikácie pomocou Charts.\nInštalácia Helm: # # MacOS brew install helm # Ubuntu/Debian curl https://baltocdn.com/helm/signing.asc | sudo apt-key add - sudo apt-get install apt-transport-https --yes echo \u0026#34;deb https://baltocdn.com/helm/stable/debian/ all main\u0026#34; | sudo tee /etc/apt/sources.list.d/helm-stable-debian.list sudo apt-get update sudo apt-get install helm # Overenie inštalácie helm version Základné Helm operácie: # # Pridanie Helm repozitára helm repo add bitnami https://charts.bitnami.com/bitnami helm repo add stable https://charts.helm.sh/stable helm repo update # Vyhľadávanie charts helm search repo nginx helm search hub wordpress # Inštalácia aplikácie helm install my-nginx bitnami/nginx # Zobrazenie nainštalovaných releases helm list # Upgrade aplikácie helm upgrade my-nginx bitnami/nginx --set replicaCount=3 # Rollback helm rollback my-nginx 1 # Odinstalovanie helm uninstall my-nginx Vytvorenie vlastného Chart: # # Vytvorenie nového chart helm create myapp # Štruktúra chart myapp/ Chart.yaml # Metadata o chart values.yaml # Defaultné hodnoty templates/ # Kubernetes manifesty deployment.yaml service.yaml ingress.yaml _helpers.tpl # Template helpers charts/ # Závislosti .helmignore # Ignorované súbory Chart.yaml: # # Chart.yaml apiVersion: v2 name: myapp description: A Helm chart for my application type: application version: 0.1.0 appVersion: \u0026#34;1.0\u0026#34; dependencies: - name: postgresql version: \u0026#34;11.9.13\u0026#34; repository: \u0026#34;https://charts.bitnami.com/bitnami\u0026#34; condition: postgresql.enabled values.yaml: # # values.yaml replicaCount: 2 image: repository: myapp pullPolicy: IfNotPresent tag: \u0026#34;latest\u0026#34; service: type: ClusterIP port: 80 ingress: enabled: true className: \u0026#34;nginx\u0026#34; annotations: nginx.ingress.kubernetes.io/ssl-redirect: \u0026#34;true\u0026#34; hosts: - host: myapp.local paths: - path: / pathType: Prefix tls: - secretName: myapp-tls hosts: - myapp.local resources: limits: cpu: 500m memory: 512Mi requests: cpu: 250m memory: 256Mi autoscaling: enabled: true minReplicas: 2 maxReplicas: 10 targetCPUUtilizationPercentage: 80 postgresql: enabled: true auth: postgresPassword: \u0026#34;supersecret\u0026#34; database: \u0026#34;myapp\u0026#34; Template deployment.yaml: # # templates/deployment.yaml apiVersion: apps/v1 kind: Deployment metadata: name: {{ include \u0026#34;myapp.fullname\u0026#34; . }} labels: {{- include \u0026#34;myapp.labels\u0026#34; . | nindent 4 }} spec: {{- if not .Values.autoscaling.enabled }} replicas: {{ .Values.replicaCount }} {{- end }} selector: matchLabels: {{- include \u0026#34;myapp.selectorLabels\u0026#34; . | nindent 6 }} template: metadata: labels: {{- include \u0026#34;myapp.selectorLabels\u0026#34; . | nindent 8 }} spec: containers: - name: {{ .Chart.Name }} image: \u0026#34;{{ .Values.image.repository }}:{{ .Values.image.tag | default .Chart.AppVersion }}\u0026#34; imagePullPolicy: {{ .Values.image.pullPolicy }} ports: - name: http containerPort: 8080 protocol: TCP env: - name: DATABASE_URL value: \u0026#34;postgresql://postgres:{{ .Values.postgresql.auth.postgresPassword }}@{{ include \u0026#34;myapp.fullname\u0026#34; . }}-postgresql:5432/{{ .Values.postgresql.auth.database }}\u0026#34; livenessProbe: httpGet: path: /health port: http initialDelaySeconds: 30 periodSeconds: 10 readinessProbe: httpGet: path: /ready port: http initialDelaySeconds: 5 periodSeconds: 5 resources: {{- toYaml .Values.resources | nindent 12 }} Testovanie a deploying Chart: # # Validácia chart helm lint myapp/ # Dry-run inštalácia helm install myapp-test ./myapp --dry-run --debug # Inštalácia s custom hodnotami helm install myapp ./myapp \\ --set replicaCount=3 \\ --set image.tag=v1.2.0 \\ --set postgresql.auth.postgresPassword=newpassword # Inštalácia s values súborom helm install myapp ./myapp -f production-values.yaml # Package chart helm package myapp/ # Push do repozitára (ak máte vlastný) helm repo index --url https://myrepo.com/charts . 15. Kubernetes Operators # Teoretický úvod # Operators sú Kubernetes aplikácie, ktoré používajú Custom Resources a Controllers na automatizáciu správy komplexných aplikácií.\nCustom Resource Definition (CRD): # # mysql-crd.yaml apiVersion: apiextensions.k8s.io/v1 kind: CustomResourceDefinition metadata: name: mysqls.database.example.com spec: group: database.example.com versions: - name: v1 served: true storage: true schema: openAPIV3Schema: type: object properties: spec: type: object properties: size: type: integer minimum: 1 maximum: 100 version: type: string enum: [\u0026#34;5.7\u0026#34;, \u0026#34;8.0\u0026#34;] storageSize: type: string pattern: \u0026#39;^[0-9]+Gi$\u0026#39; status: type: object properties: conditions: type: array items: type: object properties: type: type: string status: type: string reason: type: string scope: Namespaced names: plural: mysqls singular: mysql kind: MySQL shortNames: - mysql Custom Resource: # # mysql-instance.yaml apiVersion: database.example.com/v1 kind: MySQL metadata: name: my-database spec: size: 3 version: \u0026#34;8.0\u0026#34; storageSize: \u0026#34;10Gi\u0026#34; Populárne Operators: # Prometheus Operator: # # Inštalácia Prometheus Operator helm repo add prometheus-community https://prometheus-community.github.io/helm-charts helm install prometheus prometheus-community/kube-prometheus-stack # Vytvorenie ServiceMonitor kubectl apply -f - \u0026lt;\u0026lt;EOF apiVersion: monitoring.coreos.com/v1 kind: ServiceMonitor metadata: name: myapp-metrics spec: selector: matchLabels: app: myapp endpoints: - port: metrics path: /metrics interval: 30s EOF ArgoCD Operator: # # Inštalácia ArgoCD kubectl create namespace argocd kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml # Prístup k ArgoCD kubectl port-forward svc/argocd-server -n argocd 8080:443 # Získanie admin hesla kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath=\u0026#34;{.data.password}\u0026#34; | base64 -d 16. GitOps s ArgoCD # Teoretický úvod # GitOps je metodológia continuous deployment, kde Git repozitár slúži ako single source of truth pre infrastruktúru a aplikácie.\nArgoCD Application: # # application.yaml apiVersion: argoproj.io/v1alpha1 kind: Application metadata: name: myapp namespace: argocd spec: project: default source: repoURL: https://github.com/myorg/myapp-k8s targetRevision: main path: manifests destination: server: https://kubernetes.default.svc namespace: production syncPolicy: automated: prune: true selfHeal: true syncOptions: - CreateNamespace=true revisionHistoryLimit: 10 App of Apps pattern: # # apps.yaml apiVersion: argoproj.io/v1alpha1 kind: Application metadata: name: apps namespace: argocd spec: project: default source: repoURL: https://github.com/myorg/gitops-apps targetRevision: main path: apps destination: server: https://kubernetes.default.svc namespace: argocd syncPolicy: automated: prune: true selfHeal: true Štruktúra GitOps repozitára: # gitops-repo/ ├── apps/ │ ├── frontend.yaml │ ├── backend.yaml │ └── database.yaml ├── infrastructure/ │ ├── namespaces/ │ ├── ingress-controllers/ │ └── monitoring/ ├── environments/ │ ├── dev/ │ ├── staging/ │ └── production/ └── README.md 17. Service Mesh s Istio # Teoretický úvod # Service Mesh poskytuje komunikačnú infraštruktúru medzi mikroservices s funkciami ako load balancing, service discovery, encryption, observability.\nInštalácia Istio: # # Stiahnutie Istio curl -L https://istio.io/downloadIstio | sh - export PATH=$PWD/istio-1.19.0/bin:$PATH # Inštalácia do klastra istioctl install --set values.defaultRevision=default # Povolenie sidecar injection kubectl label namespace default istio-injection=enabled Istio Gateway a VirtualService: # # istio-gateway.yaml apiVersion: networking.istio.io/v1alpha3 kind: Gateway metadata: name: myapp-gateway spec: selector: istio: ingressgateway servers: - port: number: 80 name: http protocol: HTTP hosts: - myapp.com - port: number: 443 name: https protocol: HTTPS tls: mode: SIMPLE credentialName: myapp-tls hosts: - myapp.com --- apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: myapp-vs spec: hosts: - myapp.com gateways: - myapp-gateway http: - match: - uri: prefix: /api/ route: - destination: host: backend-service port: number: 8080 - match: - uri: prefix: / route: - destination: host: frontend-service port: number: 80 Traffic Splitting (Canary Deployment): # # canary-virtualservice.yaml apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: backend-canary spec: hosts: - backend-service http: - match: - headers: canary: exact: \u0026#34;true\u0026#34; route: - destination: host: backend-service subset: v2 - route: - destination: host: backend-service subset: v1 weight: 90 - destination: host: backend-service subset: v2 weight: 10 --- apiVersion: networking.istio.io/v1alpha3 kind: DestinationRule metadata: name: backend-destination spec: host: backend-service subsets: - name: v1 labels: version: v1 - name: v2 labels: version: v2 18. Troubleshooting a Debugging # Základné debugging príkazy: # # Zobrazenie problematických pods kubectl get pods --field-selector=status.phase!=Running # Detailné informácie o pod kubectl describe pod \u0026lt;pod-name\u0026gt; # Logs z pod kubectl logs \u0026lt;pod-name\u0026gt; -f kubectl logs \u0026lt;pod-name\u0026gt; -c \u0026lt;container-name\u0026gt; # Logs z predchádzajúceho crash kubectl logs \u0026lt;pod-name\u0026gt; --previous # Exec do pod kubectl exec -it \u0026lt;pod-name\u0026gt; -- /bin/bash # Port forwarding pre debugging kubectl port-forward pod/\u0026lt;pod-name\u0026gt; 8080:80 # Debug networking kubectl run debug --image=nicolaka/netshoot -it --rm Problematické scenáre: # Pod stuck v Pending: # # Kontrola resource constraints kubectl describe pod \u0026lt;pod-name\u0026gt; kubectl top nodes kubectl describe nodes # Kontrola taints a tolerations kubectl get nodes -o json | jq \u0026#39;.items[].spec.taints\u0026#39; ImagePullBackOff: # # Kontrola image name a tag kubectl describe pod \u0026lt;pod-name\u0026gt; # Kontrola image pull secrets kubectl get secrets kubectl describe secret \u0026lt;image-pull-secret\u0026gt; # Test pull z node docker pull \u0026lt;image-name\u0026gt; CrashLoopBackOff: # # Kontrola aplikačných logov kubectl logs \u0026lt;pod-name\u0026gt; --previous # Kontrola liveness/readiness probes kubectl describe pod \u0026lt;pod-name\u0026gt; # Dočasné vypnutie probes pre debugging kubectl patch deployment \u0026lt;deployment-name\u0026gt; -p \u0026#39;{\u0026#34;spec\u0026#34;:{\u0026#34;template\u0026#34;:{\u0026#34;spec\u0026#34;:{\u0026#34;containers\u0026#34;:[{\u0026#34;name\u0026#34;:\u0026#34;\u0026lt;container-name\u0026gt;\u0026#34;,\u0026#34;livenessProbe\u0026#34;:null,\u0026#34;readinessProbe\u0026#34;:null}]}}}}\u0026#39; Performance monitoring: # # Resource utilization kubectl top nodes kubectl top pods kubectl top pods -A # Podrobné metriky kubectl get --raw /metrics # Events v klastri kubectl get events --sort-by=\u0026#39;.lastTimestamp\u0026#39; kubectl get events -A --sort-by=\u0026#39;.lastTimestamp\u0026#39; 19. Production Best Practices # Resource Management: # # production-deployment.yaml apiVersion: apps/v1 kind: Deployment metadata: name: production-app spec: replicas: 3 strategy: type: RollingUpdate rollingUpdate: maxUnavailable: 1 maxSurge: 1 template: spec: containers: - name: app image: myapp:v1.2.3 # Vždy špecifický tag resources: requests: cpu: \u0026#34;500m\u0026#34; memory: \u0026#34;1Gi\u0026#34; limits: cpu: \u0026#34;1000m\u0026#34; memory: \u0026#34;2Gi\u0026#34; livenessProbe: httpGet: path: /health port: 8080 initialDelaySeconds: 30 periodSeconds: 10 timeoutSeconds: 5 failureThreshold: 3 readinessProbe: httpGet: path: /ready port: 8080 initialDelaySeconds: 5 periodSeconds: 5 timeoutSeconds: 3 failureThreshold: 3 env: - name: ENVIRONMENT value: \u0026#34;production\u0026#34; - name: LOG_LEVEL value: \u0026#34;info\u0026#34; Pod Disruption Budgets: # # pdb.yaml apiVersion: policy/v1 kind: PodDisruptionBudget metadata: name: myapp-pdb spec: minAvailable: 2 selector: matchLabels: app: myapp Quality Gates: # # Admission Controllers - OPA Gatekeeper apiVersion: templates.gatekeeper.sh/v1beta1 kind: ConstraintTemplate metadata: name: k8srequiredlabels spec: crd: spec: names: kind: K8sRequiredLabels validation: properties: labels: type: array items: type: string targets: - target: admission.k8s.gatekeeper.sh rego: | package k8srequiredlabels violation[{\u0026#34;msg\u0026#34;: msg}] { required := input.parameters.labels provided := input.review.object.metadata.labels missing := required[_] not provided[missing] msg := sprintf(\u0026#34;Missing required label: %v\u0026#34;, [missing]) } --- apiVersion: constraints.gatekeeper.sh/v1beta1 kind: K8sRequiredLabels metadata: name: must-have-owner spec: match: kinds: - apiGroups: [\u0026#34;apps\u0026#34;] kinds: [\u0026#34;Deployment\u0026#34;] parameters: labels: [\u0026#34;owner\u0026#34;, \u0026#34;environment\u0026#34;] Multi-cluster Strategy: # # cluster-api-cluster.yaml apiVersion: cluster.x-k8s.io/v1beta1 kind: Cluster metadata: name: production-cluster spec: clusterNetwork: services: cidrBlocks: [\u0026#34;10.128.0.0/12\u0026#34;] pods: cidrBlocks: [\u0026#34;192.168.0.0/16\u0026#34;] infrastructureRef: apiVersion: infrastructure.cluster.x-k8s.io/v1beta1 kind: AWSCluster name: production-cluster controlPlaneRef: kind: KubeadmControlPlane apiVersion: controlplane.cluster.x-k8s.io/v1beta1 name: production-cluster-control-plane 20. Záver a ďalšie kroky # 🎉 Gratulujeme! Prešli sste kompletným sprievodcom Kubernetes orchestráciou. Teraz máte solídny základ pre prácu s produkčnými Kubernetes klastrami.\nKľúčové koncepty na zapamätanie: # Pods sú základné jednotky, Deployments ich spravujú Services poskytujú stabilný prístup k aplikáciám ConfigMaps/Secrets oddeľujú konfiguráciu od kódu Ingress rieši HTTP routing a load balancing Namespaces poskytujú izoláciu a organizáciu HPA zabezpečuje automatické škálovanie Helm zjednodušuje deployment komplexných aplikácií Odporúčaný learning path: # Začiatočníci: # Praktické cvičenia s minikube Vytvorenie jednoduchých aplikácií Experimentovanie s kubectl príkazmi Pochopenie YAML manifestov Pokročilí: # Implementácia CI/CD pipeline s GitOps Service Mesh (Istio/Linkerd) Custom Controllers a Operators Multi-cluster management Advanced security (Falco, OPA) Produkcia: # Cluster autoscaling Disaster recovery stratégie Cost optimization Compliance a governance Performance tuning Užitočné zdroje: # Kubernetes oficiálna dokumentácia Kubernetes by Example CNCF Landscape Kubernetes Security Best Practices 💡 Tip: Kubernetes má strmú learning curve, ale systematické učenie a praktické skúsenosti vám pomôžu zvládnuť túto mocnú technológiu. Začnite s jednoduchými projektmi a postupne pridávajte komplexnejšie funkcie. Návod vytvoreny pomocou AI\n","date":"15 January 2025","externalUrl":null,"permalink":"/posts/kubernetes/kubernetes-orchestracia-sprievodca/","section":"Posts","summary":"","title":"Kubernetes - Kompletný sprievodca orchestráciou kontajnerov","type":"posts"},{"content":"","date":"15 January 2025","externalUrl":null,"permalink":"/tags/orchestr%C3%A1cia/","section":"Tags","summary":"","title":"Orchestrácia","type":"tags"},{"content":"Použité technológie\nÚvod # Cloudflare Tunnel je skvelé riešenie pre bezpečný prístup k vašemu OpenMediaVault serveru bez potreby vlastnenia verejnej ip adresy. V tomto návode si ukážeme, ako nastaviť Cloudflare Tunnel na OMV6 bežiacom na Odroid HC4 pomocou Docker kontajnera.\nPrečo Docker? # Použitie Docker kontajnera namiesto priamej inštalácie na host systém má niekoľko výhod:\nLepšia izolácia - kontajner beží oddelene od host systému (vyššia bezpečnosť) Jednoduchšie aktualizácie - stačí stiahnuť nový image Rýchly rollback - možnosť rýchleho návratu k predchádzajúcej verzii Minimálne privilégiá - kontajner beží s obmedzenými právami Požiadavky # Pred začatím sa uistite, že máte:\nnainštalovaný OMV6 Vlastnú doménu zaregistrovanú na Cloudflare Prístup k Cloudflare Dashboard SSH prístup k OMV serveru Krok 1: Príprava OMV6 # Inštalácia Docker pluginu # Prihlásте sa do OMV Web UI (zvyčajne http://IP_ADRESA) Prejdite na System → Plugins Nájdite a nainštalujte openmediavault-compose Po inštalácii reštartujte OMV: System → Reboot Aktivácia Docker služby # Po reštarte prejdite na Services → Compose Aktivujte službu ak nie je aktívna Krok 2: Vytvorenie Cloudflare Tunnel # Konfigurácia v Cloudflare Dashboard # Prihlaste sa na Cloudflare Dashboard Prejdite na Zero Trust → Networks → Tunnels Kliknite Create a tunnel Vyberte Cloudflared a zadajte názov (napr. \u0026ldquo;omv-tunnel\u0026rdquo;) DÔLEŽITÉ: Skopírujte tunnel token - začína s \u0026ldquo;eyJ\u0026hellip;\u0026rdquo; Nastavenie DNS záznamu # V tunnel konfigurácii pridajte Public Hostname:\nSubdomain: omv (alebo názov podľa vášho výberu) Domain: vasa-domena.com Service: HTTP://IP_OMV:80 - IP_OMV = najlepsie ak je to statická IP adresa (napriklad 192.168.1.100) Krok 3: Docker Compose konfigurácia # V OMV Web UI prejdite na Services → Compose → Add\nNázov: cloudflare-tunnel\nversion: \u0026#39;3.8\u0026#39; services: cloudflared: image: cloudflare/cloudflared:latest container_name: cloudflared-tunnel restart: unless-stopped command: tunnel --no-autoupdate run --token TVOJ_TUNNEL_TOKEN_SEM network_mode: host security_opt: - no-new-privileges:true read_only: true user: \u0026#34;65534:65534\u0026#34; # nobody user environment: - TUNNEL_METRICS=0.0.0.0:8080 healthcheck: test: [\u0026#34;CMD\u0026#34;, \u0026#34;wget\u0026#34;, \u0026#34;-q\u0026#34;, \u0026#34;--spider\u0026#34;, \u0026#34;http://localhost:8080/ready\u0026#34;] interval: 10s timeout: 3s retries: 3 # Nezabudnite nahradiť TVOJ_TUNNEL_TOKEN_SEM skutočným tokenom! Spustenie kontajnera # Kliknite Save Kliknite Up pre spustenie Skontrolujte stav v Containers tabe Krok 4: Verifikácia a testovanie # Kontrola stavu kontajnera # # SSH pripojenie k OMV ssh root@IP_OMV # Kontrola bežiaceho kontajnera docker ps | grep cloudflared # Kontrola logov docker logs cloudflared-tunnel Test pripojenia # Otvorte prehliadač a prejdite na https://omv.vasa-domena.com. Malo by sa zobraziť OMV login screen.\nPokročilá konfigurácia # Viacero služieb # Ak chcete vystaviť viac služieb, upravte nastavenia v Cloudflare Dashboard:\nIP adresa hostu na ktorom bežia služby - je to statická IP adresa (napriklad 192.168.1.100) , môžu to byť aj služby na viacerých hostoch (rôzne ip adresy)\nTunnel → Configure → Public Hostnames:\nomv.domena.com → http://192.168.1.100:80 portainer.domena.com → http://192.168.1.100:9443 nextcloud.domena.com → http://192.168.1.100:8080 Monitoring # Pre monitoring môžete pridať do compose súboru:\ntunnel-monitor: image: nicolargo/glances:latest container_name: tunnel-monitor restart: unless-stopped ports: - \u0026#34;61208:61208\u0026#34; volumes: - /var/run/docker.sock:/var/run/docker.sock:ro Riešenie problémov # Časté problémy # Tunnel sa nepripojí:\nSkontrolujte token Verifikujte DNS nastavenia v Cloudflare 403 Error:\nSkontrolujte či je doména správne nastavená Verifikujte Zero Trust nastavenia Kontajner sa reštartuje:\ndocker logs cloudflared-tunnel --tail 50 Užitočné príkazy # # Reštart tunnel docker restart cloudflared-tunnel # Live logy docker logs -f cloudflared-tunnel # Kontrola network docker network ls Bezpečnostné odporúčania # Aktivujte Cloudflare Access pre extra zabezpečenie - da sa nastavit multifaktorové overovanie, rôzne obmedzenia (napr geolokacia, \u0026hellip;) Nastavte firewall pravidlá - blokujte priamy prístup na port 80/443 Pravidelne aktualizujte Docker image Monitorujte logy pre podozrivú aktivitu Používajte silné heslá pre OMV účty Záver # Cloudflare Tunnel poskytuje bezpečný a spoľahlivý spôsob prístupu k vášmu OpenMediaVault serveru z ľubovoľného miesta na svete bez potreby verejnej ip adresy. Použitie Docker kontajnera zabezpečuje dodatočnú vrstvu izolácie a uľahčuje údržbu systému.\nTento setup je ideálny pre domácich používateľov, ktorí chcú mať vzdialený prístup k svojim súborom a službám.\nNávod vytvoreny pomocou AI\n","date":"5 October 2024","externalUrl":null,"permalink":"/posts/cloudflare/hugo-cloudflare-tunnel-post/","section":"Posts","summary":"\u003cp\u003ePoužité technológie\u003c/p\u003e\n\u003cimg src=\"https://cf-assets.www.cloudflare.com/dzlvafdwdttg/69wNwfiY5mFmgpd9eQFW6j/d5131c08085a977aa70f19e7aada3fa9/1pixel-down__1_.svg\"  width=\"150\" style=display:inline;padding:10px;\u003e\n\u003cimg src=\"https://www.openmediavault.org/wp-content/uploads/2016/09/header_logo3.png\" width=\"150\" style=display:inline;padding:10px;\u003e\n\u003cimg src=\"https://www.docker.com/app/uploads/2023/08/logo-guide-logos-1.svg\" width=\"150\" style=display:inline;padding:10px;\u003e\n\n\u003ch2 class=\"relative group\"\u003eÚvod \n    \u003cdiv id=\"úvod\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100 select-none\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700 !no-underline\" href=\"#%c3%bavod\" aria-label=\"Anchor\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003eCloudflare Tunnel je skvelé riešenie pre bezpečný prístup k vašemu OpenMediaVault serveru bez potreby vlastnenia verejnej ip adresy. V tomto návode si ukážeme, ako nastaviť Cloudflare Tunnel na OMV6 bežiacom na Odroid HC4 pomocou Docker kontajnera.\u003c/p\u003e","title":"Cloudflare Tunnel na OpenMediaVault 6, prístup bez verejnej IP","type":"posts"},{"content":"","date":"5 October 2024","externalUrl":null,"permalink":"/categories/n%C3%A1vody/","section":"Categories","summary":"","title":"Návody","type":"categories"},{"content":"","date":"5 October 2024","externalUrl":null,"permalink":"/tags/odroid/","section":"Tags","summary":"","title":"Odroid","type":"tags"},{"content":"","date":"5 October 2024","externalUrl":null,"permalink":"/tags/omv/","section":"Tags","summary":"","title":"Omv","type":"tags"},{"content":"","date":"5 October 2024","externalUrl":null,"permalink":"/categories/self-hosting/","section":"Categories","summary":"","title":"Self-Hosting","type":"categories"},{"content":"","date":"5 October 2024","externalUrl":null,"permalink":"/tags/self-hosting/","section":"Tags","summary":"","title":"Self-Hosting","type":"tags"},{"content":"","date":"5 October 2024","externalUrl":null,"permalink":"/tags/tunnel/","section":"Tags","summary":"","title":"Tunnel","type":"tags"},{"content":" nauc sa filmovat # ano nie ","externalUrl":null,"permalink":"/videos/naucsa/","section":"Videos","summary":"","title":"","type":"videos"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/videos/","section":"Videos","summary":"","title":"Videos","type":"videos"}]